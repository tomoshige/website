# 線形代数学 I / 基礎 / II：第23回講義ノート

## 1. 講義情報と予習ガイド

**講義回**: 第23回  
**テーマ**: 還元定理と余因子展開による行列式の計算  
**関連項目**: 行列式、還元定理、余因子展開  
**予習内容**: 前回の基本変形と行列式の関係について復習しておくこと

## 2. 学習目標

本講義の終了時には、以下の項目について理解し実行できるようになることを目指します：

1. 行列式計算における還元定理の意味を理解し、適用できる
2. 余因子展開の定義を理解し、行列式計算に応用できる
3. 還元定理と余因子展開を組み合わせて効率的に行列式を計算できる
4. 基本変形から還元定理が適用できる形に行列を変形できる
5. Google Colaboratoryを用いて行列式の計算を実行できる

## 3. 基本概念

### 3.1 還元定理とは

還元定理は、行列式の計算を効率化するための重要な定理です。特に行列の一部に0の要素が多く含まれる場合に有効です。

> **定義：還元定理**  
> $n$ 次正方行列 $A$ において、ある行（または列）の中に $n-1$ 個の0がある場合、残りの1つの要素 $a_{ij}$ と、その余因子 $A_{ij}$ の積が行列式の値となる。
> 
> $\det(A) = a_{ij} \cdot A_{ij}$

#### 還元定理の直感的理解と具体例

還元定理の本質は、行列式を展開する際に、0となる項を無視できることにあります。ある行または列に多くの0がある場合、行列式の計算が大幅に簡略化されます。

例えば、次の3×3行列を考えてみましょう：

$$A = \begin{pmatrix} 
4 & 0 & 0 \\
2 & 3 & 5 \\
1 & 2 & 6
\end{pmatrix}$$

この行列の第1行には、0が2つあります（$n-1=3-1=2$個の0）。還元定理によれば、行列式は次のように計算できます：

$$\det(A) = a_{11} \cdot A_{11} = 4 \cdot A_{11}$$

ここで $A_{11}$ は、$a_{11}$ の余因子です。つまり、$A$ から第1行と第1列を取り除いた小行列の行列式に $(-1)^{1+1}=1$ を掛けたものです：

$$A_{11} = \det\begin{pmatrix} 
3 & 5 \\
2 & 6
\end{pmatrix} = 3 \cdot 6 - 5 \cdot 2 = 18 - 10 = 8$$

したがって、$\det(A) = 4 \cdot 8 = 32$ となります。

通常の行列式の展開方法を使うと、多くの項の計算が必要になりますが、還元定理を使うことで一度に答えを求めることができました。

### 3.2 余因子の定義と計算

行列式の計算において、余因子（cofactor）は非常に重要な概念です。

> **定義：余因子**  
> $n$ 次正方行列 $A = (a_{ij})$ の要素 $a_{ij}$ の余因子 $A_{ij}$ は、行列 $A$ から $i$ 行と $j$ 列を取り除いてできる $(n-1)$ 次の行列（小行列）の行列式に $(-1)^{i+j}$ を掛けたものである。
> 
> $A_{ij} = (-1)^{i+j} \det(M_{ij})$
> 
> ここで、$M_{ij}$ は $A$ から $i$ 行と $j$ 列を取り除いてできる小行列である。

#### 小行列と余因子の具体例

例えば、次の3×3行列の各要素の余因子を考えてみましょう：

$$D = \begin{pmatrix} 
2 & 3 & 1 \\
4 & 1 & 5 \\
0 & 2 & 6
\end{pmatrix}$$

まず、$d_{11} = 2$ の小行列 $M_{11}$ は、$D$ から第1行と第1列を取り除いたものです：

$$M_{11} = \begin{pmatrix} 
1 & 5 \\
2 & 6
\end{pmatrix}$$

この小行列の行列式は：
$$\det(M_{11}) = 1 \cdot 6 - 5 \cdot 2 = 6 - 10 = -4$$

したがって、$d_{11}$ の余因子は：
$$D_{11} = (-1)^{1+1} \cdot \det(M_{11}) = 1 \cdot (-4) = -4$$

同様に、$d_{12} = 3$ の小行列と余因子を計算してみましょう：

$$M_{12} = \begin{pmatrix} 
4 & 5 \\
0 & 6
\end{pmatrix}$$

$$\det(M_{12}) = 4 \cdot 6 - 5 \cdot 0 = 24$$

$$D_{12} = (-1)^{1+2} \cdot \det(M_{12}) = (-1) \cdot 24 = -24$$

このように、行列の各要素について、対応する小行列の行列式に適切な符号を付けることで余因子を計算します。

#### 余因子行列

行列のすべての要素の余因子を集めたものを余因子行列と呼びます。3×3行列 $D$ の余因子行列は次のようになります：

$$D^* = \begin{pmatrix} 
D_{11} & D_{12} & D_{13} \\
D_{21} & D_{22} & D_{23} \\
D_{31} & D_{32} & D_{33}
\end{pmatrix}$$

余因子行列は、行列の逆行列を求める際にも重要な役割を果たします。実際、正則行列 $A$ の逆行列は、$A$ の余因子行列の転置を $\det(A)$ で割ったものとして計算できます：

$$A^{-1} = \frac{1}{\det(A)} \cdot (A^*)^T$$

ここで、$A^*$ は $A$ の余因子行列、$(A^*)^T$ はその転置です。

### 3.3 余因子展開とは

余因子展開は、行列式を計算するための一般的な手法であり、任意の行または列を選んで展開する方法です。

> **定義：余因子展開**  
> $n$ 次正方行列 $A = (a_{ij})$ の行列式は、任意の行 $i$ または列 $j$ について、その行または列の各要素と対応する余因子の積の和として表される。
> 
> 行による展開：$\det(A) = \sum_{j=1}^{n} a_{ij} \cdot A_{ij}$ （任意の行 $i$ について）
> 
> 列による展開：$\det(A) = \sum_{i=1}^{n} a_{ij} \cdot A_{ij}$ （任意の列 $j$ について）

#### 余因子展開の具体例

先ほどの行列 $D$ の行列式を、第1行に関する余因子展開で計算してみましょう：

$$\det(D) = d_{11} \cdot D_{11} + d_{12} \cdot D_{12} + d_{13} \cdot D_{13}$$

各要素とその余因子を計算します：

1. $d_{11} = 2$, $D_{11} = -4$ （先ほど計算した値）

2. $d_{12} = 3$, $D_{12} = -24$ （先ほど計算した値）

3. $d_{13} = 1$, $D_{13} = (-1)^{1+3} \det\begin{pmatrix} 4 & 1 \\ 0 & 2 \end{pmatrix} = 1 \cdot (4 \cdot 2 - 1 \cdot 0) = 8$

したがって、
$$\det(D) = 2 \cdot (-4) + 3 \cdot (-24) + 1 \cdot 8 = -8 - 72 + 8 = -72$$

余因子展開は、どの行または列で展開しても同じ結果になりますが、計算を簡単にするには0の多い行または列を選ぶと効率的です。例えば、この行列の第3行には0が含まれているので、第3行で展開すると計算が少し簡単になります：

$$\det(D) = d_{31} \cdot D_{31} + d_{32} \cdot D_{32} + d_{33} \cdot D_{33}$$

$$= 0 \cdot D_{31} + 2 \cdot D_{32} + 6 \cdot D_{33}$$

$d_{31} = 0$ なので、第1項は0になり、残りの2項だけ計算すればよいことがわかります。

### 3.4 還元定理と余因子展開の関係

還元定理は、余因子展開の特殊なケースと見ることができます。ある行（または列）に $n-1$ 個の0がある場合、その行（または列）に関する余因子展開では、0でない要素が1つだけになります。

例えば、次の行列の行列式を考えてみましょう：

$$C = \begin{pmatrix} 
2 & 0 & 0 \\
3 & 4 & 1 \\
5 & 2 & 6
\end{pmatrix}$$

第1行に関する余因子展開は：
$$\det(C) = c_{11} \cdot C_{11} + c_{12} \cdot C_{12} + c_{13} \cdot C_{13}$$

ただし、$c_{12} = 0$ と $c_{13} = 0$ なので：
$$\det(C) = c_{11} \cdot C_{11} = 2 \cdot C_{11}$$

これはまさに還元定理の形です。つまり、還元定理は「ある行または列にほとんど0がある場合の余因子展開の簡略化」と考えることができます。

このように、還元定理と余因子展開は密接に関連しており、どちらも行列式計算の重要なツールです。行列の構造に応じて、最も効率的な計算方法を選択することが重要です。

## 4. 理論と手法

### 4.1 還元定理の応用

還元定理を効果的に適用するためには、基本変形を用いて行列を還元形に変形することが重要です。以下のステップで行います：

1. 基本変形を用いて、ある行または列にできるだけ多くの0を作る
2. 理想的には、1つの要素を除いてすべてが0になるようにする
3. 還元定理を適用して行列式を計算する

ただし、基本変形を行った際には、行列式の値がどのように変化するかに注意する必要があります。

### 4.2 余因子展開の計算手順

還元形にならない場合でも、余因子展開を用いれば任意の行列の行列式を計算できます。計算手順は以下の通りです：

1. 計算が簡単になるように、0の多い行または列を選ぶ
2. 選んだ行または列の各要素について、対応する余因子を計算する
3. 要素と余因子の積の和を求める

### 4.3 基本変形と還元定理・余因子展開の組み合わせ

実際の行列式計算では、これらの方法を組み合わせて使用します：

1. 基本変形を用いて行列を簡単な形に変形する
2. 可能であれば還元定理を適用する
3. それでも難しい場合は余因子展開を行う
4. 小行列の行列式を計算する際も同様の手順を繰り返す

### 4.4 計算効率化のためのポイント

行列式計算を効率化するためのポイントは以下の通りです：

1. できるだけ多くの0を含む行または列を選ぶ
2. 1または-1の要素を多く含む行または列を選ぶと計算が簡単になる
3. 大きな行列の行列式計算では、還元定理と余因子展開を組み合わせる
4. 必要に応じて展開前に行基本変形を行い、計算を簡単にする

## 5. 具体的な計算例

### 5.1 還元定理の適用例

次の3次行列の行列式を還元定理を用いて計算してみましょう。

$$A = \begin{pmatrix} 
2 & 0 & 0 \\
1 & 3 & 4 \\
2 & 1 & 5
\end{pmatrix}$$

この行列の第1行には0が2つあるので、還元定理が適用できます。

$$\det(A) = a_{11} \cdot A_{11} = 2 \cdot A_{11}$$

ここで、$A_{11}$ は $a_{11}$ の余因子であり、次のように計算します：

$$A_{11} = (-1)^{1+1} \det\begin{pmatrix} 
3 & 4 \\
1 & 5
\end{pmatrix} = \det\begin{pmatrix} 
3 & 4 \\
1 & 5
\end{pmatrix} = 3 \cdot 5 - 4 \cdot 1 = 15 - 4 = 11$$

したがって、$\det(A) = 2 \cdot 11 = 22$ となります。

### 5.2 余因子展開の適用例

次の3次行列の行列式を余因子展開で計算してみましょう。

$$B = \begin{pmatrix} 
3 & 1 & 2 \\
0 & 2 & -1 \\
4 & 0 & 3
\end{pmatrix}$$

この行列は第2列に0が1つあるので、第2列で余因子展開を行うと効率的です。

$$\det(B) = b_{12} \cdot B_{12} + b_{22} \cdot B_{22} + b_{32} \cdot B_{32}$$

ここで、各余因子を計算します：

$$B_{12} = (-1)^{1+2} \det\begin{pmatrix} 
0 & -1 \\
4 & 3
\end{pmatrix} = -1 \cdot (0 \cdot 3 - (-1) \cdot 4) = -1 \cdot 4 = -4$$

$$B_{22} = (-1)^{2+2} \det\begin{pmatrix} 
3 & 2 \\
4 & 3
\end{pmatrix} = 1 \cdot (3 \cdot 3 - 2 \cdot 4) = 9 - 8 = 1$$

$$B_{32} = (-1)^{3+2} \det\begin{pmatrix} 
3 & 2 \\
0 & -1
\end{pmatrix} = -1 \cdot (3 \cdot (-1) - 2 \cdot 0) = -1 \cdot (-3) = 3$$

したがって、
$$\det(B) = 1 \cdot (-4) + 2 \cdot 1 + 0 \cdot 3 = -4 + 2 = -2$$

### 5.3 基本変形と還元定理の組み合わせ例

次の3次行列の行列式を計算してみましょう。

$$C = \begin{pmatrix} 
2 & 3 & 1 \\
4 & 5 & 2 \\
1 & 3 & 2
\end{pmatrix}$$

まず、基本変形を用いて行列に0をより多く作ります。
$R_2 - 2R_1$ と $R_3 - \frac{1}{2}R_1$ を行うと、次のようになります：

$$C' = \begin{pmatrix} 
2 & 3 & 1 \\
0 & -1 & 0 \\
0 & 1.5 & 1.5
\end{pmatrix}$$

これで第2行に0が2つできたので、還元定理が適用できます：

$$\det(C') = c'_{22} \cdot C'_{22} = -1 \cdot C'_{22}$$

ここで、

$$C'_{22} = (-1)^{2+2} \det\begin{pmatrix} 
2 & 1 \\
0 & 1.5
\end{pmatrix} = 1 \cdot (2 \cdot 1.5 - 1 \cdot 0) = 3$$

したがって、$\det(C') = -1 \cdot 3 = -3$

基本変形により行列式の値は変化するため、元の行列式との関係を考慮する必要があります。
$R_2 - 2R_1$ は行列式の値を変えませんが、$R_3 - \frac{1}{2}R_1$ も行列式の値を変えません。

したがって、$\det(C) = \det(C') = -3$ となります。

## 6. Pythonによる実装と可視化

### 6.1 行列式の計算

NumPyを用いて行列式を計算できます。

```python
import numpy as np

# 例1: 還元定理の例
A = np.array([[2, 0, 0],
              [1, 3, 4],
              [2, 1, 5]])

# NumPyのlinalg.detを使用して行列式を計算
det_A = np.linalg.det(A)
print(f"det(A) = {det_A}")

# 例2: 余因子展開の例
B = np.array([[3, 1, 2],
              [0, 2, -1],
              [4, 0, 3]])

det_B = np.linalg.det(B)
print(f"det(B) = {det_B}")

# 例3: 基本変形と還元定理の組み合わせ例
C = np.array([[2, 3, 1],
              [4, 5, 2],
              [1, 3, 2]])

det_C = np.linalg.det(C)
print(f"det(C) = {det_C}")
```

### 6.2 余因子の計算と行列式の展開

余因子を計算し、余因子展開を実装する例です。

```python
import numpy as np

def minor(A, i, j):
    """行列Aから第i行と第j列を除いた小行列の行列式を計算"""
    # numpyでは0から始まるので、i,jも0から始まるとする
    n = A.shape[0]
    # 行と列を除去
    minor_matrix = np.delete(np.delete(A, i, axis=0), j, axis=1)
    return np.linalg.det(minor_matrix)

def cofactor(A, i, j):
    """行列Aの(i,j)成分の余因子を計算"""
    return (-1)**(i+j) * minor(A, i, j)

def determinant_by_cofactor_expansion(A, row=0):
    """余因子展開により行列式を計算（指定した行について展開）"""
    n = A.shape[0]
    if n == 1:
        return A[0, 0]
    
    det = 0
    for j in range(n):
        det += A[row, j] * cofactor(A, row, j)
    
    return det

# 例：3次行列の行列式計算
B = np.array([[3, 1, 2],
              [0, 2, -1],
              [4, 0, 3]])

# NumPyの関数で計算
det_B_numpy = np.linalg.det(B)
print(f"det(B) by NumPy = {det_B_numpy}")

# 余因子展開で計算（行0について展開）
det_B_cofactor = determinant_by_cofactor_expansion(B, row=0)
print(f"det(B) by cofactor expansion (row 0) = {det_B_cofactor}")

# 余因子展開で計算（行1について展開）
det_B_cofactor_row1 = determinant_by_cofactor_expansion(B, row=1)
print(f"det(B) by cofactor expansion (row 1) = {det_B_cofactor_row1}")
```

### 6.3 還元形の確認と還元定理の適用

還元形の条件を確認し、還元定理を適用するコードです。

```python
import numpy as np

def is_reducible(A):
    """行列がある行または列にn-1個の0を持つかチェック"""
    n = A.shape[0]
    
    # 各行について0の数をチェック
    for i in range(n):
        if np.count_nonzero(A[i, :] == 0) == n-1:
            # 0でない要素の位置
            j = np.where(A[i, :] != 0)[0][0]
            return True, ('row', i, j)
    
    # 各列について0の数をチェック
    for j in range(n):
        if np.count_nonzero(A[:, j] == 0) == n-1:
            # 0でない要素の位置
            i = np.where(A[:, j] != 0)[0][0]
            return True, ('col', i, j)
    
    return False, None

def determinant_with_reduction(A):
    """還元定理を適用できる場合はそれを使って行列式を計算"""
    reducible, info = is_reducible(A)
    
    if reducible:
        type_pos, i, j = info
        if type_pos == 'row':
            # 行に注目する場合
            return A[i, j] * cofactor(A, i, j)
        else:
            # 列に注目する場合
            return A[i, j] * cofactor(A, i, j)
    else:
        # 還元形でない場合はNumPyのdet関数を使用
        return np.linalg.det(A)

# 例：還元定理が適用できる行列
A = np.array([[2, 0, 0],
              [1, 3, 4],
              [2, 1, 5]])

# 還元形かチェック
reducible, info = is_reducible(A)
if reducible:
    type_pos, i, j = info
    print(f"行列Aは還元形です。{type_pos} {i+1}に注目します。")
else:
    print("行列Aは還元形ではありません。")

# 還元定理を適用して行列式を計算
det_A_reduction = determinant_with_reduction(A)
print(f"det(A) by reduction theorem = {det_A_reduction}")

# NumPyの関数で検証
det_A_numpy = np.linalg.det(A)
print(f"det(A) by NumPy = {det_A_numpy}")
```

## 7. 演習問題

### 基本問題（概念理解の確認）

1. 次の行列の行列式を計算しなさい。
   $$A = \begin{pmatrix} 
   3 & 0 & 0 \\
   2 & 4 & 0 \\
   1 & 2 & 5
   \end{pmatrix}$$

2. 還元定理を適用できるように、次の行列に1回の行基本変形を行い、行列式を計算しなさい。
   $$B = \begin{pmatrix} 
   2 & 1 & 0 \\
   3 & 0 & 2 \\
   1 & 2 & 3
   \end{pmatrix}$$

3. 次の行列の行列式を余因子展開で計算しなさい。
   $$C = \begin{pmatrix} 
   1 & 2 & 3 \\
   0 & 1 & 4 \\
   1 & 0 & 2
   \end{pmatrix}$$

4. 行列 $D$ の余因子行列を $D^{*}$ とするとき、$D \cdot D^{*} = \det(D) \cdot I$ が成り立つことを確認しなさい。
   $$D = \begin{pmatrix} 
   2 & 1 \\
   3 & 4
   \end{pmatrix}$$

### 応用問題（応用能力の確認）

5. 4次行列の行列式を計算しなさい。（ヒント：還元定理と余因子展開を組み合わせる）
   $$E = \begin{pmatrix} 
   1 & 0 & 2 & 0 \\
   0 & 3 & 1 & 0 \\
   0 & 0 & 2 & 0 \\
   4 & 1 & 3 & 5
   \end{pmatrix}$$

6. 次の行列の行列式を、様々な方法で展開し、結果が一致することを確認しなさい。
   $$F = \begin{pmatrix} 
   3 & 2 & 1 \\
   0 & 4 & 2 \\
   1 & 0 & 5
   \end{pmatrix}$$

7. 健康データサイエンスの応用：相関行列は対称行列であり、その行列式はデータの変数間の相関の強さを表す指標となります。次の3変数の健康データに関する相関行列の行列式を計算し、変数間の相関の強さについて考察しなさい。
   $$R = \begin{pmatrix} 
   1 & 0.7 & 0.3 \\
   0.7 & 1 & 0.5 \\
   0.3 & 0.5 & 1
   \end{pmatrix}$$
   
   また、相関行列の行列式が0に近いとき、データサイエンスにおいてどのような問題が生じる可能性があるか説明しなさい。

## 8. よくある質問と解答

### Q1: 行列式を計算する際に、どの行（または列）を選んで展開するのが最も効率的ですか？

A1: 一般的には、0の要素を多く含む行または列を選ぶと計算が簡単になります。可能であれば、n-1個の0を持つ行または列があれば、還元定理を適用できるため、その行または列を選ぶのが最も効率的です。また、1や-1の要素を含む行または列も計算が簡単になることが多いです。

### Q2: 還元定理と余因子展開の違いは何ですか？

A2: 還元定理は、ある行または列にn-1個の0が存在する特殊な場合にのみ適用できる簡略化された計算方法です。一方、余因子展開は任意の行または列について適用できる一般的な展開方法です。還元定理は余因子展開の特殊なケースと考えることもできます。

### Q3: 行列式が0になるのはどのような場合ですか？

A3: 行列式が0になるのは、行列の行または列のベクトルが線形従属である場合です。具体的には：
- ある行（または列）がすべて0の場合
- ある行（または列）が別の行（または列）の定数倍である場合
- ある行（または列）が他の行（または列）の線形結合で表せる場合

### Q4: 行列式の計算において基本変形を使う際の注意点は何ですか？

A4: 基本変形によって行列式の値は以下のように変化します：
1. 行（または列）の交換：行列式の符号が反転する
2. 行（または列）の定数倍：行列式もその定数倍となる
3. ある行（または列）の定数倍を別の行（または列）に加える：行列式の値は変化しない

これらの性質を理解しておくことで、基本変形後の行列式から元の行列式を正確に計算できます。

### Q5: 余因子展開を理解する上でよくある誤解は何ですか？

A5: よくある誤解には以下のようなものがあります：
- 余因子の符号（$(-1)^{i+j}$）を忘れる
- 小行列を取る際に行と列の番号を混同する
- 余因子行列と逆行列の関係を誤解する（余因子行列の転置を行列式で割ると逆行列になる）
- すべての行または列で展開すると結果が異なると考える（実際にはどの行または列を選んでも同じ値になる）

## 9. まとめ

本講義では、行列式計算の効率的な方法として、還元定理と余因子展開について学びました。

1. 還元定理は、行列のある行または列にn-1個の0がある特殊な場合に適用でき、計算を大幅に簡略化できます。
2. 余因子展開は、任意の行または列について適用できる一般的な展開方法であり、再帰的に行列式を計算できます。
3. 実際の計算では、基本変形を用いて行列を簡単な形に変形してから、還元定理や余因子展開を適用するとよいでしょう。
4. 計算の効率化のためには、0の多い行または列、または1や-1を含む行または列を選ぶとよいです。
5. 行列式の計算はデータサイエンスにおいても重要であり、特に相関行列の行列式はデータの多重共線性の診断に用いられます。

次回の講義では、これらの知識を応用して、より大きな次数（4次以上）の行列式の計算方法について学びます。